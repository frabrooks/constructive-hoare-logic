
% DOCUMENT CLASS
\documentclass[oneside,12pt]{article}

\usepackage{graphicx}

\usepackage{agda}

\input{font-business}

% Caption options
\usepackage[font=footnotesize,labelfont=bf]{caption}

\usepackage{lipsum}

% Bold face small caps
% \usepackage{bold-extra}

%\input{unicode}
%\usepackage{eufrak}
%\usepackage{mathabx}
% Use Chancery Font


%Includes "References" in the table of contents
\usepackage[nottoc]{tocbibind}


\usepackage{ stmaryrd }% For \llbracket \rrbracket
% Used in \tctrip def

% Style for Agda snippet math script replacement
% (emphasised agda definitions)
\newcommand{\agdamath}[1]{\emph{\texttt{\!#1}}}

% style for Mini-Imp construct/mechanism
\newcommand{\impcode}[1]{\textsc{\texttt{#1}}}

\newcommand{\codevar}[1]{#1}


% For constants in agda-snippets
% Place input in circle (arg should be one numeral 1-9)
\newcommand{\constv}[1]{\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {#1}}}}

% Hoare's original notation for partial correctness
\newcommand{\hpc}[3]{$#1\{\!\!\{#2\}\!\!\}#3$}

% Gries then uses this for total correctness, but confusingly in many
% expositions these days it is used to denote partial correctness!
\newcommand{\gtc}[3]{\{\!\!\{#1\}\!\!\}\,#2\,\{\!\!\{#3\}\!\!\}}

% This reports/project's notation
% Partial Correctness Hoare-Triple
\newcommand{\pctrip}[3]{\large{\guillemotleft}\normalsize{$#1$}\large{\guillemotright}%
  \normalsize{$#2$}\large{\guillemotleft}\normalsize{$#3$}\large{\guillemotright}\normalsize}

% Total Correctness Hoare-Triple
\newcommand{\tctrip}[3]{$\large{\llbracket}\normalsize{#1}\large{\rrbracket}\,%
  \normalsize{#2}\,\large{\llbracket}\normalsize{#3}\large{\rrbracket}\normalsize$}


\newcommand{\wpre}[2]{$\textit{wp}(#1,#2)$}

\newcommand{\wlpre}[2]{$\textit{wlp}(#1,#2)$}

% Agda code state transformer symbol
\newcommand{\stateT}{\ensuremath{S\Delta}}


% def above equal sign
\newcommand{\eqdef}{$\stackrel{\text{\tiny def}}{=}$}

\begin{document}

\begin{titlepage}
  \begin{center}
    \large

    \textbf{\Large A Constructive Formalisation of Hoare Logic within the Interactive Theorem Prover Agda}

    
    \vfill

    Project Report \\
    Word Count XXXX   \\
    Fraser L. Brooks 1680975 \\
    Supervisor: Vincent Rahli
    
    \vfill
    \includegraphics[width=4cm]{Figures/birmingham_shield.png}
    \vfill
       
    Submitted in partial fulfillment \\
    of the requirements for the degree of\\
    Master of Science \\
    (Computer Science) \\
       
    \vfill
       
    at the \\
    University of Birmingham\\
    School of Computer Science\\
    July 2021
       
    \vspace{0.8cm}
       
  \end{center}
\end{titlepage}

\flushbottom

\begin{abstract}


  Program correctness is a perennial problem for software engineers and computer scientists alike. Many methods exist for establishing the correctness of a program and broadly speaking these methods fall into one of two paradigms; a program can be tested or the correctness can be `proved' outright. Due to the sheer complexity of software engineering, testing has reigned supreme in industry as formal techniques for proving correctness, while numerous, have lagged behind practice.
  However, with the advent of higher-order-logic theorem provers and dependently typed programming languages, both operating under the scope of the Curry-Howard correspondence, the gap between practice and theory is shrinking.

  Hoare logic is a formal system in which one can reason rigorously about --- and \emph{prove} --- the correctness of programs while Agda is both a dependently typed programming language \emph{and} an interactive theorem prover in accordance with the Curry-Howard correspondence. Combining the two, this work sets out to formalise the salient rules from Hoare logic within Agda and in doing so, provide a novel library with which a user could reason and prove correct simple imperative-style programs.

  This formalisation was achieved via a deep embedding of both a simple imperative language, dubbed \emph{`Mini-Imp,'} and of the propositional calculus used in the reasoning about programs in the guise of Mini-Imp's expression language. Interfaces were also used to seperate out the concerns of proving program correctness and proving trivial results within the expression language such as conjunction elimination or the distributivity of multiplication over addition.

  The final result is an Agda library that is fit for the purpose of reasoning about and proving correct simple imperative-style programs using the implemented Hoare logic rules. A limitation of the work is the simplicity of the Mini-Imp language and corresponding lack of more sophisticated logical rules meaning there is no facility for reasoning about more complex language constructs like procedures, arrays or pointers. However, more powerful logics such as `separation logic' --- an extension of Hoare logic --- could bridge this gap and owing to the expressive power of HOL, with time, there is no reason why the current library couldn't be expanded to encompass separation logic too.

  \end{abstract}

\pagebreak
  
\tableofcontents

\pagebreak

\raggedbottom

\section{Introduction}


This is some text. That will not be in my report. Lorem  ipsum  dolor  sit  amet,  consectetuer  adipiscing  
elit.   Etiam  lobortisfacilisis sem.  Nullam nec mi et 
neque pharetra sollicitudin.  Praesent imperdietmi nec ante. 
Donec ullamcorper, felis non sodales.. Lorem  ipsum  dolor  sit  amet,  consectetuer  adipiscing  
elit.   Etiam  lobortisfacilisis sem.  Nullam nec mi et 
neque pharetra sollicitudin.  Praesent imperdietmi nec ante. 
Donec ullamcorper, felis non sodales...

\section{Preliminaries \& Literature Review}

\subsection{Weakest Precondition}

How is one to give a semantics to computation? One answer is to provide a model of computation that denotes how a mechansim, a computation, or program\footnote{ the three words here being used synonymously} is to be computed; such as a Turing machine, or a FSA. Another way however is to describe what the mechanism, computation, or program can \emph{do} for us; that is, specifiying what input states it can accept, and what states it will produce.


OR: given a desired output (of states) specifying, how (read, in which input states), if at all, it can produce the desired output.

This approach gives us a way of specifying a \ldots without caring about the eventual form of the mechanism if indeed it ever takes form at all!

Computation as traversing the state space. Descartes - Cartesian product - [Dijkstra,p12]


Weakest precondition (according to Dijskstra) is unique when considered as a state space, but multiple predicates could denote the same space. (i.e. $x == y$ and $y == x$)

Strongest postcondition?
[Gries, exercise 4 section 9.1]


`If for a given $P$, $S$, and $R$, $P \Rightarrow wp(S,R)$ holds, this can often be proved without explicit formulation --- or, if you prefer, ``computation'', or ``derivation'' --- of the predicate $wp(S,R)$'




Note that in the text [dijkstra], $wp(S,R)$, is used interchangeably as a predicate and as the state space that said predicate captures. With our constructive formalisation however, this lack of precision is not possible nor desired, so we end up with the, perhaps superfluous, distinction between predicates and the state space that they describe. Meaning that under our formalisation, $wp(S,F)$ is empty when considered as a state space, but inhabited when considered as a predicate (inhabited uniquely by $F$ itself). This exposition also explains why \pctrip{F}{S}{Q} is an inhabited type, as $F$ \emph{is} a valid precondition of any computation for any postcondition (think absurd function, or bluff function). $<<$ Actually explained by the fact that what we have formalised is the weakest \emph{liberal} precodnition!


Weakest Liberal Precondition is what has actually been formalised! Total correctness is denoted by \tctrip{P}{S}{Q}


7 regions of the statesapce. As such, we can --- if we wish --- give a semantics to the notion of a derterministic mechanism as one in which the last four regions of the state space are empty.

\subsection{Hoare Logic}


\subsection{Agda}

\subsection{Constructive Mathematics}

`Agda is a constructive mathematical system by default, which amounts to saying that it can also be considered as a
programming language for manipulating mathematical objects.' - MHE


\subsection{Formal Proof}

\subsection{Applications}

\section{Specification}



\subsection{Obfuscating Interfaces}

Might have also wanted to abstract away expression language
(page 42 surface properties (Ligler))


x and y refer to possibly identical identifiers, while z is guaranteed to be distinct from both x and y. With more time a more expansive interface would be given allowing for as many identifiers as were necessary to reason about the desired program along with a mechanism for obtaining free identifiers from an expression, with the identifiers being represented as natural numbers, a new \emph{free} identifier could always be generated by summing the numerical value of the identifiers present in the supplied expression, or in a given list.

\subsection{Exppresion Language}

Carving up state space.
Every predicate denotes a subset of the statespace
(which in our case is infinite).

(day = 23) Dijkstra's example

T/F, x == 2

Relationship between logical operators and set theoretic operators
i.e. $\wedge \Leftrightarrow \cap$

{\advance\leftskip\mathindent

\input{agda-snippets/expressions-even}

}

Ought to have differentiated between non stuck-ness and termination. I.e. D(E) as domain of expression E, to eliminate divide by zero and non-defined variables in an expression, as that is a problem that can be handled distinctly from termination
(i.e. (I think anway) that given a state S, and an expression E, one can deterministically/decidably determine whether or not it is a WFF).

Donec ullamcorper, felis non sodales.. Lorem  ipsum  dolor  sit  amet,  consectetuer  adipiscing  
elit.

{\advance\leftskip\mathindent
  \advance\leftskip\mathindent
  
\input{agda-snippets/assertions-wff-def}

}

Donec ullamcorper, felis non sodales.. Lorem  ipsum  dolor  sit  amet,  consectetuer  adipiscing  
elit.

{\advance\leftskip\mathindent
  \advance\leftskip\mathindent

\input{agda-snippets/assertions-assert-def-2}

}

Donec ullamcorper, felis non sodales.. Lorem  ipsum  dolor  sit  amet,  consectetuer  adipiscing  
elit. 
Donec ullamcorper, felis non sodales.. Lorem  ipsum  dolor  sit  amet,  consectetuer  adipiscing  
elit.

{\centering \input{agda-snippets/assertions-implication}}


Donec ullamcorper, felis non sodales.. Lorem  ipsum  dolor  sit  amet,  consectetuer  adipiscing  
elit. 
Donec ullamcorper, felis non sodales.. Lorem ipsum  dolor  sit  amet,  consectetuer  adipiscing  
elit.


\begin{figure}
  \caption{Example of reasoning with the deep embedding of propositional logic}
  \centering
  
  \begin{tabular}{cc}
    \centering
    \begin{minipage}[t]{0.45\textwidth}
      \centering
      \input{agda-snippets/assertions-a1-def}
    \end{minipage}

    &
   
      \begin{minipage}[t]{0.45\textwidth}
        \centering
        \input{agda-snippets/assertions-a2-def}
      \end{minipage}
      
    \\
    
    \multicolumn{2}{c}{
    \begin{minipage}{0.9\textwidth}
      \centering
      \vspace{-0.5cm}
      \input{agda-snippets/assertions-inference-proof}
    \end{minipage}}
 
  \end{tabular}

\end{figure}

\lipsum[66]

{\centering \input{agda-snippets/example-progs-swap}}

\lipsum[75]


\begin{figure}
 \caption{Some simple programs defined with Mini-Imp; ripe for reasoning!}

\begin{tabular}{r|l}
  \centering
  \footnotesize
\begin{minipage}[t]{0.4\textwidth}
  \centering
  \input{agda-snippets/example-progs-gcd}
\end{minipage}

& 
   
\begin{minipage}[t]{0.5\textwidth}
  \centering
  \footnotesize
  \advance\leftskip0.2cm
  \input{agda-snippets/example-progs-mul-add}
\end{minipage}

\end{tabular}

\end{figure}

\begin{figure}
  \caption{The deep embedding in Agda of our `Mini-Imp' imperative language.}
  \advance\leftskip2\mathindent
  \input{agda-snippets/mini-imp-definition}

\end{figure}

\lipsum[63]


{\advance\leftskip2\mathindent
  \input{agda-snippets/mini-imp-then-def}
  \input{agda-snippets/mini-imp-then-comm}
}


\lipsum[63]

\input{agda-snippets/evaluation-eval-foo-type}

\lipsum[66]

{\centering
\input{agda-snippets/evaluation-eval-while-case}

\vspace{-1cm}

\input{agda-snippets/evaluation-eval-while-c2-case}
}

\lipsum[75]



\lipsum[66]

{\advance\leftskip1.5\mathindent

\input{agda-snippets/termination-termination-def}

\vspace{-0.8cm}

\input{agda-snippets/termination-termination-cond-def}

\vspace{-0.8cm}

\input{agda-snippets/termination-indexed}

\vspace{-0.8cm}

\input{agda-snippets/termination-indexed-cond}

}

\lipsum[75]

{\small \input{agda-snippets/termination-eval-det-signature}}


\lipsum[34]

{\centering \input{agda-snippets/termination-tsplit-record}}

\lipsum[67]

{\centering \input{agda-snippets/semantics-pc-trip}}

\lipsum[66]

{\centering \input{agda-snippets/semantics-tc-trip}}

\lipsum[66]

{\centering \input{agda-snippets/semantics-lem}}

\lipsum[66]



\subsection{Language}


\subsection{Axioms \& Rules}


\lipsum[75]

\lipsum[66]

\lipsum[66]


\vbox{\centering
  \input{agda-snippets/rules-axiom-of-assi}
}

\lipsum[66]

\vbox{\centering
  \input{agda-snippets/rules-cons-post}
}

\vbox{\centering
  \input{agda-snippets/rules-cons-pre}
}

\lipsum[66]

\vbox{\centering
  \input{agda-snippets/rules-comp}
}

\lipsum[66]

\vbox{\centering
  \input{agda-snippets/rules-while}
}

\lipsum[66]

\vbox{\centering
  \input{agda-snippets/rules-conditional}
}



\begin{figure}
  \caption{D3-While: Full proof of the while rule; the crucial rule for reasoning with Hoare Logic:}
  \centering
  \small
  \input{agda-snippets/rules-while-proof-p1}
  {\centering \hfill \Huge{\vdots} \hfill }
\end{figure}

\begin{figure}\ContinuedFloat
  \caption{D3-While: Full proof of the while rule; the crucial rule for reasoning with Hoare Logic:}
  \vspace{-0.8cm}
  \begin{center}\!\!\!\small{cont.}\end{center}
  {\centering \hfill \Huge{\vdots} \hfill }
   \centering
   \small
   \input{agda-snippets/rules-while-proof-p2}
\end{figure}


\section{Implementation}

\subsection{Constructive Termination}


\lipsum[66-69]


\subsection{Small Step Evaluation with Fuel}


\lipsum[66-69]


\subsection{Termination Splitting}


\lipsum[66-75]


\subsection{Axiom \& Rules in Agda}


\begin{figure}
  \caption{ssEvalwithFuel: The small-step evaluation function}
  \centering
  \input{agda-snippets/evaluation-eval-full-p1}
  {\centering \hfill \Huge{\vdots} \hfill }
\end{figure}

\begin{figure}\ContinuedFloat
  \caption{ssEvalwithFuel cont.}
  \centering
  { \hfill \Huge{\vdots} \hfill }
  \input{agda-snippets/evaluation-eval-full-p2}
\end{figure}

\begin{figure}
  \caption{The full proof that evaluation is deterministic via proof that for any two proofs of termination, the resultant states serving as evidence for each of those proofs - in accordance with them being \emph{constructive} proofs - will be identical.  \\ n.b. that the $\dagger$ function is the function that extracts the witness from the proof of termination - i.e. the resultant state after the computation has terminated successfully.}
  \centering
  \scriptsize
  \input{agda-snippets/termination-eval-det-full}
\end{figure}

\begin{figure}
  \caption{[t]-split: The function for splitting two proofs of termination. }
  \footnotesize
  {\centering \input{agda-snippets/termination-tsplit-full-p1}}
  {\centering \hfill \Huge{\vdots} \hfill }
\end{figure}

\begin{figure}\ContinuedFloat
  \caption{[t]-split cont. \\
   n.b. some cases have been omitted but none that vary from the general pattern here. }
  \footnotesize
  {\centering \hfill \Huge{\vdots} \hfill }
  {\centering \input{agda-snippets/termination-tsplit-full-p3}}
\end{figure}



\subsection{Using the System to Reason about Programs}

Reasoning about swap was done for constants but a similar proof could be implemented with any expression as long as the variables to be swapped were also swapped across the whole expression. For example:


\begin{figure}
  \caption{SWAP: Using the library to formalise the correctness of the SWAP program:}
  \small
  {\centering \input{agda-snippets/swap-example-p1}}
  {\centering \hfill \Huge{\vdots} \hfill }
\end{figure}

\begin{figure}\ContinuedFloat
  \caption{SWAP: Using the library to formalise the correctness of the SWAP program:}
  \small
  \vspace{-0.5cm}
  \begin{center}\!\!\!\small{cont.}\end{center}
  {\centering \hfill \Huge{\vdots} \hfill }
  {\centering \input{agda-snippets/swap-example-p2}}
  {\centering \hfill \Huge{\vdots} \hfill }
\end{figure}

\begin{figure}\ContinuedFloat
  \caption{SWAP: Using the library to formalise the correctness of the SWAP program:}
  \small
  \vspace{-0.5cm}
  \begin{center}\!\!\!\small{cont.}\end{center}
  {\centering \hfill \Huge{\vdots} \hfill }
  {\centering \input{agda-snippets/swap-example-p3}}
\end{figure}


\begin{verbatim}
< x == y + 1 > $\leftarrow$ sub x for z
  
z := x (z == y + 1) $\leftarrow$ sub y for x

x := y (z == x + 1) $\leftarrow$ sub z for y

y := z <y == x + 1 >

\end{verbatim}


Some maths: \texttt{$\ll$\!\,\,P\,\,\!$\gg$\!\,\,C\,\,\!$\ll$\!\,\,Q\,\,\!$\gg$} test test hello hello
 
\section{Evaluation}


\subsection{Using Agda}

Getting better at working with Agda --- thanks to unicode suport, psychological bias of aesthetic but incorrect signature.


\subsection{Missteps}


Downsides: Having to define all logical manipulations in the interface. Some mechanism for making this less painful would be nice. Equally however, said logical manipulations are not really of the main concern. Just because nothing can be postulated for the proof to have a computational meaning, doesn't mean we need be bound by this restriction. Indeed, there is little reason for us to care about whether or not our proofs have this computational context so long as we trust the parts we omit, and as these ommisions are oft simple logical manipulations, leaving them only in the record but not actually proved would be perfectly sensible and allow more focus to be on the manipulation of Hoare triples to reason about programs.

Actually, if I was doing it again, it would have been very sensible to not bother with implementing the interfaces at all. It was probably not a worthwhile use of my time to prove De Morgans law, or the commutativity of boolean and, in Agda when I could have instead focused on the more salient parts of the code base.

\subsection{Future Work}

Gries page 164 'a fine balance between the two' 
\ldots but! automation, Infer,


parse a C program and create formal proof in background. Complain if fail

If the Agda code is to work as a library, there had ought to be some functionality for allowing potential users to add to Data-Implementation.agda, to define their own logical rules.


Ref paper: tactics for separation logic and how some reworking of data-interface could allow full use of HOL in Agda when manipulating assertions.


\subsection{Conclusion}

Hoare's surprise at test case success (see retrospective)

Not all that useful in practice, other tools are far more sophisticated and far better suited to practical applications, whether that be the verified software toolchain for reasoning about embedded software that needs to be correct, or Infer for catching a litany of bugs before they make their way into production. There's not a lot of room to claim that this Agda library has any real practical purpose. But that doesn't mean no purpose.

Constructive mathematics and interactive theorem provers are not front and center in mainstream mathematics, and perhaps never will be, but one oft talked about benefits of constructive mathematics is quite simply that it is fun to do [link MHE blog post] and it is on that note that one finds the most compelling use for this Agda library; it's actually a lot of fun --- if you're of a particular sort --- to reason about even the most simple of programs. I certainly found it enjoyable to reason about the swap program and have Agda check my workings for me.

Never been so intimately aquainted with the three lines of code comprising the swap function.


\section{Appendix}


\nocite{*}

\bibliographystyle{plain}

\bibliography{report}
 
\end{document}

