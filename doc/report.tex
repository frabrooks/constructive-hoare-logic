
% DOCUMENT CLASS
\documentclass[oneside,12pt]{article}

\usepackage{graphicx}

\usepackage{agda}

%\input{unicode}
%\usepackage{eufrak}
%\usepackage{mathabx}
% Use Chancery Font
\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}
% Use: \mathpzc{abc...z} for lowercase mathscript

%Includes "References" in the table of contents
\usepackage[nottoc]{tocbibind}

% For \begin{lstlisting} which = verbatim
% environment with escapable math
%\usepackage{listings}% http://ctan.org/pkg/listings
%\lstset{
%  mathescape
%}

\begin{document}


\begin{titlepage}
  \begin{center}
    \large

    \textbf{\Large A Constructive Formalisation of Hoare Logic using the Interactive Theorem Prover Agda}

    
    \vfill

    Project Report \\
    Word Count XXXX   \\
    Fraser L. Brooks 1680975 \\
    Supervisor: Vincent Rahli
    
    \vfill
    \includegraphics[width=4cm]{Figures/birmingham_shield.png}
    \vfill
       
    Submitted in partial fulfillment \\
    of the requirements for the degree of\\
    Master of Science \\
    (Computer Science) \\
       
    \vfill
       
    at the \\
    University of Birmingham\\
    School of Computer Science\\
    July 2021
       
    \vspace{0.8cm}
       
  \end{center}
\end{titlepage}

\flushbottom

\begin{abstract}

Problem, Approach, What you Produced, Evaluation, What it all means. Nullam enim nisi, elementum eu pellentesque nec, facilisis id tellus. Sed erat sem, maximus vel fermentum et, fringilla quis est. Aliquam tempus nunc ac velit sollicitudin condimentum. Duis sed rutrum tellus. Curabitur rutrum finibus justo ut malesuada. Nullam tincidunt scelerisque iaculis. Quisque tempor massa id urna elementum, sit amet condimentum tellus euismod. Integer est eros, posuere et lacus finibus, pretium aliquam libero.

Mauris scelerisque aliquam vehicula. Fusce id sodales lacus, vitae eleifend ex. Nulla facilisi. Maecenas placerat sem imperdiet ex pellentesque, in ultricies odio vulputate. Nulla facilisi. Donec eget suscipit sapien. Aenean ipsum neque, cursus quis magna nec, porttitor viverra enim. Nulla tellus augue, convallis at mattis eget, pellentesque et odio. Etiam suscipit, libero nec pretium posuere, leo erat posuere enim, non accumsan nisi mi ac libero. Morbi tortor diam, venenatis vitae nisi non, vulputate hendrerit diam. Nam eget nulla turpis.

Donec posuere mi id pellentesque volutpat. Proin ultricies diam ut velit ultricies congue. Duis molestie aliquet lectus a sodales. Integer mollis sed leo in commodo. Suspendisse potenti. Etiam nec libero quis sapien porttitor vehicula. Proin eleifend dolor egestas, dapibus leo at, pulvinar velit. Proin id erat a turpis accumsan iaculis non sit amet purus. Integer porta, eros non elementum bibendum, libero eros elementum turpis, at fringilla sem sapien hendrerit mi.

Praesent consequat ut mi vel ullamcorper. Nullam a nisi bibendum, ultrices risus at, volutpat neque. Quisque tincidunt ac elit sed pellentesque. Integer sed tristique lectus. Pellentesque lacinia pellentesque magna in viverra. Aenean pharetra sit amet quam non molestie. Nam dictum quam sit amet eros sodales interdum. Morbi porttitor lectus lorem. Sed sagittis ante est, at tempor mauris dictum a. Suspendisse nec est vitae augue porta posuere quis eu velit. Nullam euismod nunc ut eleifend congue. Aliquam fermentum, lectus vel mollis tempor.

  \end{abstract}

\pagebreak
  
\tableofcontents

\pagebreak

\raggedbottom

\section{Introduction}

This is some text. That will not be in my report. Lorem  ipsum  dolor  sit  amet,  consectetuer  adipiscing  
elit.   Etiam  lobortisfacilisis sem.  Nullam nec mi et 
neque pharetra sollicitudin.  Praesent imperdietmi nec ante. 
Donec ullamcorper, felis non sodales.. Lorem  ipsum  dolor  sit  amet,  consectetuer  adipiscing  
elit.   Etiam  lobortisfacilisis sem.  Nullam nec mi et 
neque pharetra sollicitudin.  Praesent imperdietmi nec ante. 
Donec ullamcorper, felis non sodales...

\section{Preliminaries \& Literature Review}

\subsection{Weakest Precondition}

How is one to give a semantics to computation? One answer is to provide a model of computation that denotes how a mechansim, a computation, or program\footnote{ the three words here being used synonymously} is to be computed; such as a Turing machine, or a FSA. Another way however is to describe what the mechanism, computation, or program can \emph{do} for us; that is, specifiying what input states it can accept, and what states it will produce.


OR: given a desired output (of states) specifying, how (read, in which input states), if at all, it can produce the desired output.

This approach gives us a way of specifying a \ldots without caring about the eventual form of the mechanism if indeed it ever takes form at all!

Computation as traversing the state space. Descartes - Cartesian product - [Dijkstra,p12]


Weakest precondition (according to Dijskstra) is unique when considered as a state space, but multiple predicates could denote the same space. (i.e. $x == y$ and $y == x$)

Strongest postcondition?
[Gries, exercise 4 section 9.1]


`If for a given $P$, $S$, and $R$, $P \Rightarrow wp(S,R)$ holds, this can often be proved without explicit formulation --- or, if you prefer, ``computation'', or ``derivation'' --- of the predicate $wp(S,R)$'




Note that in the text [dijkstra], $wp(S,R)$, is used interchangeably as a predicate and as the state space that said predicate captures. With our constructive formalisation however, this lack of precision is not possible nor desired, so we end up with the, perhaps superfluous, distinction between predicates and the state space that they describe. Meaning that under our formalisation, $wp(S,F)$ is empty when considered as a state space, but inhabited when considered as a predicate (inhabited uniquely by $F$ itself). This exposition also explains why $<<F>> S <<Q>>$ is an inhabited type, as $F$ \emph{is} a valid precondition of any computation for any postcondition (think absurd function, or bluff function). $<<$ Actually explained by the fact that what we have formalised is the weakest \emph{liberal} precodnition!


Weakest Liberal Precondition is what has actually been formalised! (Need to work out the translation)


7 regions of the statesapce. As such, we can --- if we wish --- give a semantics to the notion of a derterministic mechanism as one in which the last four regions of the state space are empty.

\subsection{Hoare Logic}


\subsection{Agda}

\subsection{Constructive Mathematics}

`Agda is a constructive mathematical system by default, which amounts to saying that it can also be considered as a
programming language for manipulating mathematical objects.' - MHE



\subsection{Formal Proof}

\subsection{Applications}

\section{Specification}

\subsection{Obfuscating Interfaces}

Might have also wanted to abstract away expression language
(page 42 surface properties (Ligler))


x and y refer to possibly identical identifiers, while z is guaranteed to be distinct from both x and y. With more time a more expansive interface would be given allowing for as many identifiers as were necessary to reason about the desired program along with a mechanism for obtaining free identifiers from an expression, with the identifiers being represented as natural numbers, a new \emph{free} identifier could always be generated by summing the numerical value of the identifiers present in the supplied expression, or in a given list.

\subsection{Exppresion Language}

Carving up state space.
Every predicate denotes a subset of the statespace
(which in our case is infinite).

(day = 23) Dijkstra's example

T/F, x == 2

Relationship between logical operators and set theoretic operators
i.e. $\wedge \Leftrightarrow \cap$


Ought to have differentiated between non stuck-ness and termination. I.e. D(E) as domain of expression E, to eliminate divide by zero and non-defined variables in an expression, as that is a problem that can be handled distinctly from termination
(i.e. (I think anway) that given a state S, and an expression E, one can deterministically/decidably determine whether or not it is a WFF).



\subsection{Language}

A S$\Delta$ is one of the following:

\input{agda/Language/LangCon}

\subsection{Axioms \& Rules}

\section{Implementation}

\subsection{Constructive Termination}

\subsection{Small Step Evaluation with Fuel}

\subsection{Termination Splitting}

\subsection{Axiom \& Rules in Agda}

\subsection{Using the System to Reason about Programs}


Reasoning about swap was done for constants but a similar proof could be implemented with any expression as long as the variables to be swapped were also swapped across the whole expression. For example:


\begin{verbatim}
< x == y + 1 > $\leftarrow$ sub x for z
  
z := x (z == y + 1) $\leftarrow$ sub y for x

x := y (z == x + 1) $\leftarrow$ sub z for y

y := z <y == x + 1 >

\end{verbatim}


Hello, some maths: \texttt{$\ll$\!\,\,P\,\,\!$\gg$\!\,\,C\,\,\!$\ll$\!\,\,Q\,\,\!$\gg$} test test hello hello
 
\section{Evaluation}


\subsection{Agda \& Beautiful Verbosity}

Getting better at working with Agda --- thanks to unicode suport, psychological bias of aesthetic but incorrect signature.


\subsection{Missteps}


Downsides: Having to define all logical manipulations in the interface. Some mechanism for making this less painful would be nice. Equally however, said logical manipulations are not really of the main concern. Just because nothing can be postulated for the proof to have a computational meaning, doesn't mean we need be bound by this restriction. Indeed, there is little reason for us to care about whether or not our proofs have this computational context so long as we trust the parts we omit, and as these ommisions are oft simple logical manipulations, leaving them only in the record but not actually proved would be perfectly sensible and allow more focus to be on the manipulation of Hoare triples to reason about programs.

Actually, if I was doing it again, it would have been very sensible to not bother with implementing the interfaces at all. It was probably not a worthwhile use of my time to prove De Morgans law, or the commutativity of boolean and, in Agda when I could have instead focused on the more salient parts of the code base.

\subsection{Future Work}

Gries page 164 'a fine balance between the two' 
\ldots but! automation, Infer,

\ldots BUT WHAT ABOUT FUN??

parse a C program and create formal proof in background. Complain if fail

If the Agda code is to work as a library, there had ought to be some functionality for allowing potential users to add to Data-Implementation.agda, to define their own logical rules.



\subsection{Conclusion}

Hoare's surprise at test case success (see retrospective)

Not all that useful in practice, other tools are far more sophisticated and far better suited to practical applications, whether that be the verified software toolchain for reasoning about embedded software that needs to be correct, or Infer for catching a litany of bugs before they make their way into production. There's not a lot of room to claim that this Agda library has any real practical purpose. But that doesn't mean no purpose.

Constructive mathematics and interactive theorem provers are not front and center in mainstream mathematics, and perhaps never will be, but one oft talked about benefits of constructive mathematics is quite simply that it is fun to do [link MHE blog post] and it is on that note that one finds the most compelling use for this Agda library; it's actually a lot of fun --- if you're of a particular sort --- to reason about even the most simple of programs. I certainly found it enjoyable to reason about the swap program and have Agda check my workings for me.

Never been so intimately aquainted with the three lines of code comprising the swap function.


\section{Appendix}


\nocite{*}

\bibliographystyle{plain}

\bibliography{report}


  
\end{document}
