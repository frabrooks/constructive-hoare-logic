

@book{Dijkstra76,
  author    = {Edsger W. Dijkstra},
  title     = {A Discipline of Programming},
  publisher = {Prentice-Hall},
  year      = {1976},
  isbn      = {013215871X},
  timestamp = {Fri, 17 Jul 2020 16:12:44 +0200},
  biburl    = {https://dblp.org/rec/books/ph/Dijkstra76.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@book{Gries81,
  author    = {David Gries},
  title     = {The Science of Programming},
  series    = {Texts and Monographs in Computer Science},
  publisher = {Springer},
  year      = {1981},
  url       = {https://doi.org/10.1007/978-1-4612-5983-1},
  doi       = {10.1007/978-1-4612-5983-1},
  isbn      = {978-0-387-96480-5},
  timestamp = {Tue, 16 May 2017 14:01:46 +0200},
  biburl    = {https://dblp.org/rec/books/sp/Gries81.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@incollection{KNUTH1970263,
title = {Simple Word Problems in Universal Algebras},
editor = {John Leech},
booktitle = {Computational Problems in Abstract Algebra},
publisher = {Pergamon},
pages = {263-297},
year = {1970},
isbn = {978-0-08-012975-4},
doi = {https://doi.org/10.1016/B978-0-08-012975-4.50028-X},
url = {https://www.sciencedirect.com/science/article/pii/B978008012975450028X},
author = {Knuth, Donald E. and Bendix, Peter B.},
abstract = {Summary
An algorithm is described which is capable of solving certain word problems: i.e. of deciding whether or not two words composed of variables and operators can be proved equal as a consequence of a given set of identities satisfied by the operators. Although the general word problem is well known to be unsolvable, this algorithm provides results in many interesting cases. For example in elementary group theory if we are given the binary operator ·, the unary operator −, and the nullary operator e, the algorithm is capable of deducing from the three identities a · (b · c) = (a · b) · c, a · a− = e, a · e = a, the laws a− · a = e, e · a = a, a– = a, etc.; and furthermore it can show that a · b = b · a− is not a consequence of the given axioms. The method is based on a well-ordering of the set of all words, such that each identity can be construed as a “reduction”, in the sense that the right-hand side of the identity represents a word smaller in the ordering than the left-hand side. A set of reduction identities is said to be “complete” when two words are equal as a consequence of the identities if and only if they reduce to the same word by a series of reductions. The method used in this algorithm is essentially to test whether a given set of identities is complete; if it is not complete the algorithm in many cases finds a new consequence of the identities which can be added to the list. The process is repeated until either a complete set is achieved or until an anomalous situation occurs which cannot at present be handled. Results of several computational experiments using the algorithm are given.}
}

@article{hoare1969axiomatic,
  title={An axiomatic basis for computer programming},
  author={Hoare, Charles Antony Richard},
  journal={Communications of the ACM},
  volume={12},
  number={10},
  pages={576--580},
  year={1969},
  publisher={ACM New York, NY, USA}
}

@article{hoare2009viewpoint,
  title={Viewpoint retrospective: An axiomatic basis for computer programming},
  author={Hoare, Charles Antony Richard},
  journal={Communications of the ACM},
  volume={52},
  number={10},
  pages={30--32},
  year={2009},
  publisher={ACM New York, NY, USA}
}

% Original Separation Logic Publication
@inproceedings{reynolds2002separation,
  title={Separation logic: A logic for shared mutable data structures},
  author={Reynolds, John C},
  booktitle={Proceedings 17th Annual IEEE Symposium on Logic in Computer Science},
  pages={55--74},
  year={2002},
  organization={IEEE}
}


@inproceedings{10.1145/800191.805513,
author = {Ligler, George T.},
title = {The Assignment Axiom and Programming Language Design},
year = {1976},
isbn = {9781450374897},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800191.805513},
doi = {10.1145/800191.805513},
abstract = {One way to approach software reliability is to design programming languages that satisfy
criteria which ensure that undesirable semantic effects cannot occur. The effect of
using the assignment rule of Hoare as such a criterion on the design of procedure-oriented,
block-structured programming languages is investigated; after details of the Hoare
formalism are discussed, language design guidelines derived from formal studies are
informally presented and justified.},
booktitle = {Proceedings of the 1976 Annual Conference},
pages = {2–6},
numpages = {5},
location = {Houston, Texas, USA},
series = {ACM '76}
}


@inproceedings{10.1145/512976.512982,
author = {Ligler, George T.},
title = {A Mathematical Approach to Language Design},
year = {1975},
isbn = {9781450373517},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/512976.512982},
doi = {10.1145/512976.512982},
abstract = {A framework for validating surface properties of programming language constructs,
composed of proof rules (akin to those of Hoare) and supporting hypotheses, is constructed
using the mathematical semantics of Scott and Strachey. The following approach to
language design is then considered: the constructs of a language should have surface
properties which 1) need few hypotheses other than assumed surface properties; and
2) have proofs consisting, as far as possible, of trivial fixpoint and structural
inductions.},
booktitle = {Proceedings of the 2nd ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
pages = {41–53},
numpages = {13},
location = {Palo Alto, California},
series = {POPL '75}
}






