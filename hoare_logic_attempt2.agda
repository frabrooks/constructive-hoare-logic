


import Relation.Binary.PropositionalEquality as Eq
open Eq using ( _โก_  ; refl ; sym ; cong)
--open import Relation.Nullary.Reflects
--open import Relation.Nullary.Decidable
open import Data.Empty
open import Relation.Nullary
open import Relation.Nullary.Decidable using (False ; True ; isYes ; isNo ; โ_โ )
open import Data.Bool as Bool renaming (Bool to ๐น) using ( true ; false) 
open import Data.Integer as Int using (โค ; _+_ ; _-_ ; _*_ )
open import Data.Integer.Base using (โฃ_โฃ )  
open import Data.Integer.DivMod using ( _div_ ; _mod_ )
open import Data.List as List using (List; _โท_; [] ; map ; _++_ )
open import Data.String.Properties using (_โ?_)
open import Data.Nat as โ renaming (_+_ to _โ_ ; _*_ to _โ_ ) using (โ; zero; suc; _โธ_; _โค_; pred ; _โ_ ; _โค?_)
open import Data.Maybe using (Maybe)
open import Data.Maybe.Categorical as Cโ
--open import Data.Maybe.Relation.Binary.Pointwise using (Pointwise ; drop-just)
open import Data.Product renaming (_,_ to _โง_  )

open Maybe
open โค


open import Agda.Builtin.Unit
open import Data.Empty using (โฅ)


pattern [_] z = z โท []
pattern [_,_] y z = y โท z โท []
pattern [_,_,_] x y z = x โท y โท z โท []
pattern [_,_,_,_] w x y z = w โท x โท y โท z โท []
pattern [_,_,_,_,_] v w x y z = v โท w โท x โท y โท z โท []
pattern [_,_,_,_,_,_] u v w x y z = u โท v โท w โท x โท y โท z โท []



open import integer_operations


module Programs where

  open import Data.Product


  Id = โ
  Val = โค

  data Expr  : Set where
    Constant : Val โ Expr
    Var : Id โ Expr
    Op : OpName โ List Expr โ Expr


  Entry = Id ร Val

  S = List Entry

  updateState : Id โ Val โ S โ S
  updateState i z  []  = [( i โง z )]
  updateState i e ((fst โง snd) โท zs)  with fst โ i
  ...                                 | yes _ = (i โง e) โท zs
  ...                                 | no _ = (fst โง snd ) โท updateState i e zs
  

  getVar : Id โ S โ Maybe Val
  getVar i [] = nothing
  getVar i ((fst โง snd) โท zs) with โ i โ fst โ
  ...                                 | true =  just snd 
  ...                                 | false = getVar i zs


  evalArgs : S โ List Expr โ List (Maybe โค)
  evalArgs s [] = []
  evalArgs s (Constant x โท es) = (just x) โท evalArgs s es
  evalArgs s (Var x โท es)      = (getVar x s) โท evalArgs s es 
  evalArgs s (Op op exps โท es) = let args = evalArgs s exps in (opEval op args) โท evalArgs s es

  
  eval :  Expr โ S -> Maybe โค
  eval (Constant x) s = just x
  eval (Var x)      s = getVar x s
  eval (Op op exps) s = opEval op (evalArgs s exps)

  {-
  data โคPropValue : List Id โ Set where
    Con : โค โ โคPropValue []
    Var : โ {i : Id} โ โคPropValue (i โท []) 
    -- TODO: Add expressions so [(X + 1) > 3] can be a goal?


  data ๐นPropValue : List Id โ Set where
    Con : ๐น โ ๐นPropValue []
    --Var : Id โ ๐นPropValue


  data โคProp : List Id โ Set where
    eqPโค      : โ {l r : List Id} โ โคPropValue l โ โคPropValue r โ โคProp (l ++ r)
    LeqPโค     : โ {l r : List Id} โ โคPropValue l โ โคPropValue r โ โคProp (l ++ r)
    LessPโค    : โ {l r : List Id} โ โคPropValue l โ โคPropValue r โ โคProp (l ++ r)
    GeqPโค     : โ {l r : List Id} โ โคPropValue l โ โคPropValue r โ โคProp (l ++ r)
    GreaterPโค : โ {l r : List Id} โ โคPropValue l โ โคPropValue r โ โคProp (l ++ r)
  -}

  {- Trying: Add List Id as indexed data type ? -}
  
  data โคPropValue : Set where
    Con : โค โ โคPropValue
    Var : Id โ โคPropValue
    -- TODO: Add expressions so [(X + 1) > 3] can be a goal?


  data ๐นPropValue : Set where
    Con : ๐น โ ๐นPropValue
    --Var : Id โ ๐นPropValue


  data โคProp : Set where
    eqPโค      : โคPropValue โ โคPropValue โ โคProp
    LeqPโค     : โคPropValue โ โคPropValue โ โคProp
    LessPโค    : โคPropValue โ โคPropValue โ โคProp
    GeqPโค     : โคPropValue โ โคPropValue โ โคProp
    GreaterPโค : โคPropValue โ โคPropValue โ โคProp
  

  -- Maybe need to be xplicit about which variable the proposition holds for rather than generalise over all variables in the store
  
  data PROPO : Set where
    ๐นโข        : ๐นPropValue โ PROPO
    ๐นโค        : โคProp โ PROPO
    eq๐น       : PROPO โ PROPO โ PROPO
    ๐นโง        : PROPO โ PROPO โ PROPO
    ๐นV        : PROPO โ PROPO โ PROPO
    -- ๐นยฌ        : PROPO โ PROPO
  

  {-
  data PROPO : List Id โ Set where
    ๐นโข       : โ {l : List Id} โ ๐นPropValue l โ PROPO l
    ๐นโค       : โ {l : List Id} โ โคProp l โ PROPO l
    eq๐น      : โ {l r : List Id} โ PROPO l โ PROPO r โ PROPO (l ++ r) -- does this make sense???
    ๐นโง       : โ {l r : List Id} โ PROPO l โ PROPO r โ PROPO (l ++ r)
    ๐นV       : โ {l r : List Id} โ PROPO l โ PROPO r โ PROPO (l ++ r)


  data holds : {ls : List Id} โ S โ PROPO ls โ Set where
    CCEq :  โ {x y : โค} โ {s : S} โ (x โก y) โ holds s (๐นโค    (eqPโค (Con x) (Con y))  )
    VCEq :  โ {x y : โค} โ {id : Id} โ {s : S} โ (๐นโค  (eqPโค  ?       ?    ) )  
  -}


  
  {-    
  data holds : List Id โ PROPO โ S โ Set where
    CCEq : โ {vars : Id} โ {x y : โค} โ { s : S } โ ( x โก y ) โ holds vars ( ๐นโค (eqPโค (Con x) (Con y) ) ) s
    CVEq : โ {vars : Id} โ {x y : โค} โ { s : S } โ {id idโ : Id} โ ( x โก y ) โ (id โก idโ) โ holds vars (๐นโค (eqPโค (Con x) (Var id))) ((idโ , y) โท s )  
    VCEq : โ {vars : Id} โ {x y : โค} โ { s : S } โ {id idโ : Id} โ ( x โก y ) โ (id โก idโ) โ holds vars (๐นโค (eqPโค (Var id) (Con x))) ((idโ , y) โท s )
    VVEq : โ {vars : Id} โ {x y : โค} โ { s : S } โ {idโ idโ idโโ idโโ : Id} โ ( x โก y ) โ (idโ โก idโโ) โ (idโ โก idโโ) โ holds vars (๐นโค (eqPโค (Var idโ) (Var idโ))) ((idโ , x) โท (idโ , y) โท s)
    ANDHolds : โ {vars : Id} โ {p q : PROPO} โ {s : S} โ holds vars p s โ holds vars q s โ holds vars (๐นโง p q) s
    ORHoldL  : โ {vars : Id} โ {p q : PROPO} โ {s : S} โ holds vars p s โ holds vars (๐นV p q) s
    ORHoldR  : โ {vars : Id} โ {p q : PROPO} โ {s : S} โ holds vars q s โ holds vars (๐นV p q) s
  -}



  data hasValue : Id โ โค โ S โ Set where
    atthehead : โ i z s โ hasValue i z ((i , z) โท s)
    elsewhere : โ i j z w s s' โ i โก j โ โฅ โ hasValue i z s โ s' โก ((j , w) โท s ) โ hasValue i z s'



  {- This doesn't seem to be working too well with the function 'getVar' within the constructor. Going to try and change to have the same property encoded in a data type
  data holds : PROPO โ S โ Set where
    CCEq : โ {x y : โค} โ { s : S } โ ( x โก y ) โ holds ( ๐นโค (eqPโค (Con x) (Con y) ) ) s
    CVEq : โ {x y : โค} โ { s : S } โ {id : Id} โ ( x โก y ) โ getVar id s โก just (y) โ  holds (๐นโค (eqPโค (Con x) (Var id))) s  
    VCEq : โ {x y : โค} โ { s : S } โ {id : Id} โ ( x โก y ) โ getVar id s โก just (y) โ  holds (๐นโค (eqPโค (Var id) (Con x))) s
    VVEq : โ {x y : โค} โ { s : S } โ {idโ idโ : Id} โ ( x โก y ) โ getVar idโ s โก just (x) โ getVar idโ s โก just (y) โ holds (๐นโค (eqPโค (Var idโ) (Var idโ))) s
    ANDHolds : โ {p q : PROPO} โ {s : S} โ holds p s โ holds q s โ holds (๐นโง p q) s
    ORHoldL  : โ {p q : PROPO} โ {s : S} โ holds p s โ holds (๐นV p q) s
    ORHoldR  : โ {p q : PROPO} โ {s : S} โ holds q s โ holds (๐นV p q) s
  -}
  
  data holds : PROPO โ S โ Set where
    CCEq : โ {x y : Val} โ { s : S } โ ( x โก y ) โ holds ( ๐นโค (eqPโค (Con x) (Con y) ) ) s
    CVEq : โ (x y : Val) โ (s : S) โ (id : Id) โ x โก y โ hasValue id y s โ  holds (๐นโค (eqPโค (Con x) (Var id))) s  
    VCEq : โ (x y : Val) โ (s : S) โ (id : Id) โ x โก y โ hasValue id y s โ  holds (๐นโค (eqPโค (Var id) (Con x))) s
    VVEq : โ (x y : Val) โ ( s : S ) โ (idโ idโ : Id) โ x โก y โ hasValue idโ x s โ hasValue idโ y s โ holds (๐นโค (eqPโค (Var idโ) (Var idโ))) s
    ANDHolds : โ (p q : PROPO) โ (s : S) โ holds p s โ holds q s โ holds (๐นโง p q) s
    ORHoldL  : โ (p q : PROPO) โ (s : S) โ holds p s โ holds (๐นV p q) s
    ORHoldR  : โ (p q : PROPO) โ (s : S) โ holds q s โ holds (๐นV p q) s
  -- Todo: swap order of arguments around to make more intelligible

  sub : โค โ Id โ PROPO โ PROPO
  sub f i (๐นโข (Con x)) = ๐นโข (Con x)
  sub f i (๐นโค (eqPโค (Con x) (Con xโ))) = ๐นโค (eqPโค (Con x) (Con xโ))
  sub f i (๐นโค (eqPโค (Con x) (Var xโ))) with i โ xโ
  ...                                       | yes _ = ๐นโค (eqPโค (Con x) (Con f))
  ...                                       | no _ = ๐นโค (eqPโค (Con x) (Var xโ))
  sub f i (๐นโค (eqPโค (Var x) (Con xโ))) with i โ x
  ...                                       | yes _ = ๐นโค (eqPโค (Con f) (Con xโ))
  ...                                       | no _ = ๐นโค (eqPโค (Var x) (Con xโ))
  sub f i (๐นโค (eqPโค (Var x) (Var xโ))) with โ i โ x โ | โ i โ xโ โ
  ...                                       | true  | true = ๐นโค (eqPโค (Con f) (Con f))
  ...                                       | true  | false = ๐นโค (eqPโค (Con f) (Var xโ))
  ...                                       | false | true = ๐นโค (eqPโค (Var x) (Con f))
  ...                                       | false | false = ๐นโค (eqPโค (Var x) (Var xโ))
  sub f i (๐นโค (LeqPโค (Con x) (Con xโ))) = ๐นโค (LeqPโค (Con x) (Con xโ))
  sub f i (๐นโค (LeqPโค (Con x) (Var xโ))) with โ i โ xโ โ
  ...                                       | true = ๐นโค (LeqPโค (Con x) (Con f))
  ...                                       | false = ๐นโค (LeqPโค (Con x) (Var xโ))
  sub f i (๐นโค (LeqPโค (Var x) (Con xโ))) with โ i โ x โ
  ...                                       | true = ๐นโค (LeqPโค (Con f) (Con xโ))
  ...                                       | false = ๐นโค (LeqPโค (Var x) (Con xโ))
  sub f i (๐นโค (LeqPโค (Var x) (Var xโ))) with โ i โ x โ | โ i โ xโ โ
  ...                                       | true  | true = ๐นโค (LeqPโค (Con f) (Con f))
  ...                                       | true  | false = ๐นโค (LeqPโค (Con f) (Var xโ))
  ...                                       | false | true = ๐นโค (LeqPโค (Var xโ) (Con f))
  ...                                       | false | false = ๐นโค (LeqPโค (Var x) (Var xโ))
  sub f i (๐นโค (LessPโค (Con x) (Con xโ))) = ๐นโค (LessPโค (Con x) (Con xโ))
  sub f i (๐นโค (LessPโค (Con x) (Var xโ))) with โ i โ xโ โ
  ...                                       | true = ๐นโค (LessPโค (Con x) (Con f))
  ...                                       | false = ๐นโค (LessPโค (Con x) (Var xโ))
  sub f i (๐นโค (LessPโค (Var x) (Con xโ))) with โ i โ x โ
  ...                                       | true = ๐นโค (LessPโค (Con f) (Con xโ))
  ...                                       | false = ๐นโค (LessPโค (Var x) (Con xโ))
  sub f i (๐นโค (LessPโค (Var x) (Var xโ))) with โ i โ x โ | โ i โ xโ โ
  ...                                       | true  | true = ๐นโค (LessPโค (Con f) (Con f))
  ...                                       | true  | false = ๐นโค (LessPโค (Con f) (Var xโ))
  ...                                       | false | true = ๐นโค (LessPโค (Var xโ) (Con f))
  ...                                       | false | false = ๐นโค (LessPโค (Var x) (Var xโ))
  sub f i (๐นโค (GeqPโค (Con x) (Con xโ))) = ๐นโค (GeqPโค (Con x) (Con xโ))
  sub f i (๐นโค (GeqPโค (Con x) (Var xโ))) with โ i โ xโ โ
  ...                                       | true = ๐นโค (GeqPโค (Con x) (Con f))
  ...                                       | false = ๐นโค (GeqPโค (Con x) (Var xโ))
  sub f i (๐นโค (GeqPโค (Var x) (Con xโ))) with โ i โ x โ
  ...                                       | true = ๐นโค (GeqPโค (Con f) (Con xโ))
  ...                                       | false = ๐นโค (GeqPโค (Var x) (Con xโ))
  sub f i (๐นโค (GeqPโค (Var x) (Var xโ))) with โ i โ x โ | โ i โ xโ โ
  ...                                       | true  | true = ๐นโค (GeqPโค (Con f) (Con f))
  ...                                       | true  | false = ๐นโค (GeqPโค (Con f) (Var xโ))
  ...                                       | false | true = ๐นโค (GeqPโค (Var xโ) (Con f))
  ...                                       | false | false = ๐นโค (GeqPโค (Var x) (Var xโ))
  sub f i (๐นโค (GreaterPโค (Con x) (Con xโ))) = ๐นโค (GreaterPโค (Con x) (Con xโ))
  sub f i (๐นโค (GreaterPโค (Con x) (Var xโ))) with โ i โ xโ โ
  ...                                       | true = ๐นโค (GreaterPโค (Con x) (Con f))
  ...                                       | false = ๐นโค (GreaterPโค (Con x) (Var xโ))
  sub f i (๐นโค (GreaterPโค (Var x) (Con xโ))) with โ i โ x โ
  ...                                       | true = ๐นโค (GreaterPโค (Con f) (Con xโ))
  ...                                       | false = ๐นโค (GreaterPโค (Var x) (Con xโ))
  sub f i (๐นโค (GreaterPโค (Var x) (Var xโ))) with โ i โ x โ | โ i โ xโ โ
  ...                                       | true  | true = ๐นโค (GreaterPโค (Con f) (Con f))
  ...                                       | true  | false = ๐นโค (GreaterPโค (Con f) (Var xโ))
  ...                                       | false | true = ๐นโค (GreaterPโค (Var xโ) (Con f))
  ...                                       | false | false = ๐นโค (GreaterPโค (Var x) (Var xโ))
  sub f i (eq๐น p pโ) = eq๐น (sub f i p) (sub f i pโ)
  sub f i (๐นโง p pโ) = ๐นโง (sub f i p) (sub f i pโ)
  sub f i (๐นV p pโ) = ๐นV (sub f i p) (sub f i pโ)
  

  {-
  data holds : โคPropValue โ โคProp โ โคPropValue โ S โ Set where
    CCEq : โ {x y : โค} โ { s : S } โ (x โก y) โ  holds (Con x) eqPโค (Con y) s 
    CVEq : โ {x y : โค} โ {id idโ : โ} โ { s : S } โ (id โก idโ) โ (x โก y) โ holds (Con x) eqPโค (Var id) ((idโ , y) โท s)
    VCEq : โ {x y : โค} โ {id idโ : โ} โ { s : S } โ (id โก idโ) โ (x โก y) โ holds (Var id) eqPโค (Con x) ((idโ , y) โท s)
    VVEq : โ {x y : โค} โ {idโ idโ idโโ idโโ : โ} โ (idโ โก idโโ) โ (idโ โก idโโ) โ (x โก y) โ holds (Var idโ) eqPโค (Var idโ) ((idโโ , x) โท (idโโ , y) โท [] )
 
  -}



  data AssiProgram : Id โ โค โ Set where
    asi : {id : Id} โ {f : โค} โ  AssiProgram id f 


  -- Need to figure out how to get around Maybe on retreival from storage??
  evalAssi : โ {i : Id} โ {f : โค} โ S โ AssiProgram i f โ S
  evalAssi   {i} {f}  s asi  = updateState i f s
  --evalAssi {id} {Var x} s asi = updateState id {!getVar x s = Maybe!} {!!}

  {-
  data isEq : โคProp โ Set where
    โขโข : isEq eqPโค 
  -}



  

{-
  test : โ {s : S} โ {f : โค} โ { p : PROPO } โ ( x y : Id ) โ ( ( x โก y ) โ โฅ ) โ holds p ( ( x โง f ) โท s ) โ holds p s
  test {s} {f} {.(๐นโค (eqPโค (Con _) (Con _)))} x y no (CCEq xโ) = CCEq xโ
  test {.[]} {f} {.(๐นโค (eqPโค (Con f) (Var x)))} x y no (CVEq refl singleton) = CVEq {!!} {!!}
  test {s} {f} {.(๐นโค (eqPโค (Con f) (Var x)))} x y no (CVEq refl elsewhere) = CVEq {!!} {!!}
  test {s} {f} {.(๐นโค (eqPโค (Var _) (Con _)))} x y no (VCEq xโ xโ) = {!!}
  test {s} {f} {.(๐นโค (eqPโค (Var _) (Var _)))} x y no (VVEq xโ xโ xโ) = {!!}
  test {s} {f} {.(๐นโง _ _)} x y no (ANDHolds h hโ) = {!!}
  test {s} {f} {.(๐นV _ _)} x y no (ORHoldL h) = {!!}
  test {s} {f} {.(๐นV _ _)} x y no (ORHoldR h) = {!!}
-}
  

  drop-just : โ {A : Set} โ {x y : A} โ
            just x โก just y โ x โก y
  drop-just refl = refl

{-
  simpleGet : โ (s : S) โ (x : Id) โ (f y : โค) โ getVar x (updateState x f s)  โก just y โ f โก y
  simpleGet [] x f y get with โ x โ x  โ
  ...                         | true = drop-just get
  simpleGet (xโ โท s) x f y get with โ projโ xโ โ x โ
  ...                               | false = {!!}
  ...                               | true with โ x โ x โ
  ...                                           | false = {!!}
  ...                                           | true = drop-just get
-}


  --
  hasValueSame' : โ x y f s s' โ s' โก (updateState x f s) โ hasValue x y s' โ y โก f
  hasValueSame' x y .y [] .([ (x , y) ]) refl (atthehead .x .y .[]) = refl
  hasValueSame' x y f (xโ โท s) .((x , y) โท sโ) w (atthehead .x .y sโ) with projโ xโ โ x
  hasValueSame' x y .y (xโ โท s) ((.x , .y) โท .s) refl (atthehead .x .y .s) | yes _ = refl
  hasValueSame' x y f (.(x , y) โท s) ((.x , .y) โท .(updateState x f s)) refl (atthehead .x .y .(updateState x f s)) | no p = โฅ-elim (p refl)

  hasValueSame : โ x y f s โ hasValue x y (updateState x f s) โ y โก f
  hasValueSame x y f s hv =  hasValueSame' x y f s (updateState x f s) refl hv


  --
  hasValueDiff' : โ x x' y f s s' โ ยฌ x โก x' โ s' โก (updateState x' f s) โ hasValue x y s' โ hasValue x y s
  hasValueDiff' x .x y .y [] .([( x , y )]) d refl (atthehead .x .y .[]) = โฅ-elim (d refl)
  hasValueDiff' x x' y f ((fst , snd) โท s) .((x , y) โท sโ) d e (atthehead .x .y sโ) with fst โ x'
  hasValueDiff' .x' x' y .y ((fst , snd) โท s) ((.x' , .y) โท .s) d refl (atthehead .x' .y .s) | yes p = โฅ-elim (d refl)
  hasValueDiff' .fst x' y f ((fst , .y) โท s) ((.fst , .y) โท .(updateState x' f s)) d refl (atthehead .fst .y .(updateState x' f s)) | no p = atthehead fst y s


  hasValueDiff : โ x x' y f s โ ยฌ x โก x' โ hasValue x y (updateState x' f s) โ hasValue x y s
  hasValueDiff x x' y f s d hv =  hasValueDiff' x x' y f s (updateState x' f s) d refl hv


  --
  axiomOfAssignment : โ (s : S) (x : Id) (f : โค) (p : PROPO) (assi : AssiProgram x f)
                      โ holds  p  (evalAssi {x} {f} s assi)
                      โ holds (sub f x p)  s
  axiomOfAssignment s x f (๐นโค (eqPโค (Con xโ) (Con xโ))) asi (CCEq xโ) = CCEq xโ
  axiomOfAssignment s x f (๐นโค (eqPโค (Con xโ) (Var xโ))) asi (CVEq x' y' s' id' xโ xโ) with x โ xโ
  ... | yes z =  let e1 = hasValueSame xโ y' f s in
                 let e2 = Eq.subst (ฮป x โ hasValue xโ y' (updateState x f s)) z xโ in
                 CCEq (Eq.trans xโ (e1 e2))
  ... | no z =  let d : ยฌ xโ โก x
                    d = ฮป e โ โฅ-elim (z (Eq.sym e)) in
                let e1 = hasValueDiff xโ x y' f s d xโ in
                CVEq xโ y' s xโ xโ e1
  axiomOfAssignment s x f (๐นโค (eqPโค (Var xโ) (Con xโ))) asi (VCEq .xโ y .(updateState x f s) .xโ xโ xโ) with (x โ xโ)
  ... | yes p = let e1 = hasValueSame xโ y f s in
                let e2 = e1 (Eq.subst _  p xโ) in
                CCEq (sym (Eq.trans xโ e2))
  ... | no  ยฌp = let d : ยฌ xโ โก x
                     d = ฮป e โ โฅ-elim (ยฌp (sym e)) in
                 let e1 = hasValueDiff xโ x y f s d xโ  in
                 VCEq xโ y s xโ xโ e1
  axiomOfAssignment s x f (๐นโค (eqPโค (Var xโ) (Var xโ))) asi (VVEq xโ y .(updateState x f s) .xโ .xโ xโ xโ xโ) with (x โ xโ) | (x โ xโ)
  ... | yes p | yes pโ = CCEq refl
  ... | yes p | no ยฌp = let d : ยฌ xโ โก x
                            d = ฮป e โ โฅ-elim (ยฌp (sym e)) in
                        let e1 = hasValueDiff  xโ x y f s d xโ in
                        let fstsub = Eq.subst _ p xโ in
                        let sndsub = Eq.subst _ xโ fstsub in
                        let e2 = hasValueSame xโ y f s sndsub in
                        CVEq f y s xโ (sym e2) e1
  ... | no ยฌp | yes p = let d : ยฌ xโ โก x
                            d = ฮป e โ โฅ-elim (ยฌp (sym e)) in
                        let e1 = hasValueDiff xโ x y f s d (Eq.subst _ xโ xโ) in
                        let e2 = hasValueSame xโ y f s (Eq.subst _ p xโ) in
                        VCEq f  y s xโ (sym e2) e1
  ... | no ยฌp | no ยฌpโ = let d1 : ยฌ xโ โก x
                             d1 = ฮป e โ โฅ-elim (ยฌp (sym e)) in
                         let d2 : ยฌ xโ โก x
                             d2 = ฮป e โ โฅ-elim (ยฌpโ (sym e)) in
                         let e1 = hasValueDiff xโ x xโ f s d1 xโ  in
                         let e2 = hasValueDiff xโ x y f s d2 xโ   in
                         VVEq xโ y s xโ xโ xโ e1 e2 
  axiomOfAssignment s x f (๐นโง p pโ) asi (ANDHolds .p .pโ .(updateState x f s) h hโ) =
                         let IH1 = axiomOfAssignment s x f p asi h in
                         let IH2 = axiomOfAssignment s x f pโ asi hโ in
                         ANDHolds (sub f x p) (sub f x pโ) s IH1 IH2
  axiomOfAssignment s x f (๐นV p pโ) asi (ORHoldL .p .pโ .(updateState x f s) h) =
                         let IH = axiomOfAssignment s x f p asi h in
                         ORHoldL (sub f x p) _ s IH
  axiomOfAssignment s x f (๐นV p pโ) asi (ORHoldR .p .pโ .(updateState x f s) h)  =
                         let IH = axiomOfAssignment s x f pโ asi h in
                         ORHoldR _ (sub f x pโ) s IH
  {-
  with x โ xโ
  ... | yes z = let e1 = hasValueSame xโ y f s in
                let e2 = e1 (Eq.subst _ z xโ) in
                CCEq (Eq.sym (Eq.trans xโ e2))
  ... | no z = let d : ยฌ xโ โก x
                   d = ฮป e โ โฅ-elim (z (Eq.sym e)) in
               let e1 = hasValueDiff xโ x y f s d xโ in
               VCEq xโ y s xโ xโ e1

  -}


  {-
  axiomOfAssignment {s} {x} {f} {๐นโค (eqPโค (Con xโ) (Con xโ))} {asi} (CCEq xโ) = CCEq xโ
  axiomOfAssignment {s} {x} {f} {๐นโค (eqPโค (Con xโ) (Var xโ))} {asi} (CVEq xโ xโ xโ) with โ x โ xโ โ
  ...                                                                                    | true  = let foo = x โก xโ in  CCEq {!!} 
  ...                                                                                    | false = {!!}
  axiomOfAssignment {s} {x} {f} {๐นโค (eqPโค (Var xโ) xโ)} {asi} holdAfterAssi = {!!}
  axiomOfAssignment {s} {x} {f} {๐นโง p pโ} {asi} holdAfterAssi = {!!}
  axiomOfAssignment {s} {x} {f} {๐นV p pโ} {asi} holdAfterAssi = {!!}
  -}

  

  data Program : Set where
    Block : List Program โ Program
    Assignment : Id โ Expr โ Program
    While : Expr โ Program -> Program
    If : Expr โ Program -> Program
    IfElse : Expr โ Program โ Program -> Program
       




module Hoare where


  -- Pโ { x := f } Pโ
  -- Pโ = any state in which f can be evaluated
  -- Pโ = state with x = f
  --axiomOfAssignment : {Pโ Pโ : S โ Set} โ
  --                    (โ (s : S) โ Pโ s ) โ
                      
  

